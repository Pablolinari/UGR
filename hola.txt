\chapter{Asignación de aulas}
En esta sección se estudia lo referente al algoritmo usado para resolver el segundo 
problema el cual nos pide lo siguiente :

Se quieren ralizar N exámenes en un día en la ETSIIT , el centro cuenta con m aulas donde m es mayor
que N . Sin embargo cada vez que se utiliza un aula el centro debe contratar un vigilante por tanto 
se debe diseñar un algoritmo que clacule en base al horario de los exámenes el menor costo posible 
para la escuela , es decir hay que encontrar la manera de distribuir los exámenes para usar el menor número
de aulas posibles .

\section{Estructura de los datos}
Una vez planteado el problema porcedemos a describir las herramientas que hemos usado para resolverlo 
Para representar los horarios de los exámenes hemos usado la siguiente estructura :

\begin{lstlisting}[language=C++]
      struct tiempo{
            int hora;
            int min;
            tiempo(int h , int m){
                hora = h;
                min = m ;
            }
      };
      struct examen{
            tiempo inicio; // Hora de inicio
            tiempo final; // Hora de finalización
            examen(tiempo t , tiempo t1) : inicio(t), final(t1){}
      };
        
      struct compare{
            bool operator()(const examen&a,const examen&b){
                if(a.inicio.hora==b.inicio.hora){
                    return a.inicio.min < b.inicio.min;
                }
                return a.inicio.hora < b.inicio.hora;
            }
      };
        
\end{lstlisting}

El struct compare se utiliza para ordenar el vector de entrada de exámenes de manera que se ordenen
de menor a mayor en función de la hora de inicio de los exámenes , de esta manera se facilita la
ejecución del algoritmo que se encarga de asignar los exámenes a las aulas de la manera más eficiente
posible.

\section{Algoritmo}

A continuación vemos el algoritmo usado para la distribución de las aulas.

\begin{lstlisting}[language=C++]
      bool sesolapan(examen e1,examen e2){
            if(e1.final.hora == e2.inicio.hora){
                return e1.final.min >e2.inicio.min;
            }
            return e1.final.hora > e2.inicio.hora;
        }
        
        int minAulas(const vector<examen> & v){
        
            // Conjunto de candidatos v
        
            int naulas = 1;
            vector<queue<examen>> horario;
            //Conjunto de seleccionados horario (vector de colas , cada cola es un aula)
            
            horario.emplace_back(queue<examen>());
            horario[0].push(v[0]);
            int i;
            //
            for(int nex = 1;nex < v.size();nex++){
                i=0;
                //Funcion de seleccion
                while(i<horario.size() && (sesolapan(horario[i].back(),v[nex]))){i++;}
                //Funcion de factibilidad
                if(i==horario.size()){
                    horario.emplace_back(queue<examen>());
                    horario[i].push(v[nex]);
                    naulas++;
                }
                else{
                    horario[i].push(v[nex]);
                }
            }
            return naulas; //Funcion objetivo 
      }
\end{lstlisting}

Uno de los factores importantes que hay que destacar de este algoritmo es que el vector \textbf{v} se supone 
ordenado de mayor a menor , es decir que en el vector los exámenes aparecen en orden creciente de 
horario de inicio de esta manera la asignación de aulas es más rápida y eficiente.

El algoritmo comienza añadiendo el primer examen al primer aula , cada aula se representa con una posición del vector 
y el horarario del aula se representa con una cola ya que solo nos interesa el último examen hecho en el aula.

Posteriormente se entra al bucle for el cual recorre todo el vector de candidatos ya que todos los exámenes deben
ser realizados . 

Dentro del bucle for se entra a un while el cual comprueba mediante la función \textbf{sesolapan(examen e1 ,examen e2)}
si el examen que está buscando un aula se solapa con el que se está realizando en el aula , si no se solapan se añade a 
ese aula , si se solapan se busca otra aula en la que no se solapen y se añade a esa aula. En el caso de que se hallan agotado
las aulas actuales se crea una nueva aula y se añade el examen a esa aula.
 
\section{Justificación Greedy}

En este apartado vamos a analizar el algoritmo identificando los componentes que lo hacen un algoritmo greedy 
y demostrando que siempre llega a la solución óptima. 

