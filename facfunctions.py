import streamlit as st
import pandas as pd
import pyodbc

# --- GESTIÓN DE CONEXIÓN CENTRALIZADA ---
def inicializar_conexion():
    """Verifica e inicializa la conexión a Oracle."""
    if 'cursor' not in st.session_state:
        try:
            # Busca driver de Oracle
            driver_list = [d for d in pyodbc.drivers() if "Oracle" in d]
            if not driver_list:
                st.error("❌ No se encontró el driver de Oracle.")
                return False
            
            driver = driver_list[0]
            
            hostname = 'oracle0.ugr.es'
            puerto = '1521'
            servicio = 'practbd'
            usuario = 'x5571079'    
            contrasenia = 'x5571079'
            
            connstr = (
                f'DRIVER={{{driver}}};'
                f'DBQ=//{hostname}:{puerto}/{servicio};'
                f'UID={usuario};'
                f'PWD={contrasenia};'
            )
            
            connection = pyodbc.connect(connstr)
            st.session_state.connection = connection
            st.session_state.cursor = connection.cursor()
            return True

        except pyodbc.Error as ex:
            st.error(f"❌ Error de conexión: {ex}")
            return False
    else:
        return True

####CREAR Y BORRAR TABLAS 
def creartodastablas(cursor):
    ### PACIENTES 
    cursor.execute("""
    CREATE TABLE PACIENTE (
        NSS VARCHAR(12) PRIMARY KEY,
        DNI VARCHAR(9) UNIQUE,
        Nombre VARCHAR(20),
        Apellidos VARCHAR(40),
        Telefono VARCHAR(20),
        Direccion VARCHAR(100),
        Fnac DATE
    )""")

    cursor.execute("""
    CREATE TABLE INGRESO (
        Id_Ingreso VARCHAR(20) PRIMARY KEY,
        Fecha_Ingreso DATE,
        Motivo VARCHAR(250),
        Sala VARCHAR(20),
        Estado VARCHAR(20),
        NSS VARCHAR(12),
        FOREIGN KEY (NSS) REFERENCES PACIENTE(NSS)
    )""")
    ##MEDICAMENTOS 
 
    # Tabla principal de medicamentos
    cursor.execute("""
    CREATE TABLE MEDICAMENTOS (
        Codigo_Med VARCHAR2(10) NOT NULL,
        Nombre VARCHAR2(50) NOT NULL,
        Proveedor VARCHAR2(50),
        Coste NUMBER(10, 2),
        Precio NUMBER(10, 2),
        F_Registro DATE DEFAULT SYSDATE,
        CONSTRAINT PK_MEDICAMENTOS PRIMARY KEY (Codigo_Med)
    )""")
    
    # Tabla de control de stock por lotes
    cursor.execute("""
    CREATE TABLE STOCK (
        Codigo_Med VARCHAR2(10) NOT NULL,
        Lote VARCHAR2(20) NOT NULL,
        Cantidad NUMBER(10) DEFAULT 0 NOT NULL,
        F_Caducidad DATE NOT NULL,
        CONSTRAINT PK_STOCK PRIMARY KEY (Codigo_Med, Lote),
        CONSTRAINT FK_STOCK_MED FOREIGN KEY (Codigo_Med) 
            REFERENCES MEDICAMENTOS(Codigo_Med) ON DELETE CASCADE,
        CONSTRAINT CK_STOCK_POSITIVO CHECK (Cantidad >= 0)
    )""")
    
    # Tabla de historial de movimientos
    cursor.execute( """
    CREATE TABLE MOVIMIENTOS (
        ID_Movimiento NUMBER GENERATED BY DEFAULT AS IDENTITY,
        Codigo_Med VARCHAR2(10) NOT NULL,
        Fecha DATE DEFAULT SYSDATE NOT NULL,
        Tipo VARCHAR2(20) NOT NULL,
        Cantidad NUMBER(10) NOT NULL,
        ID_Admin VARCHAR2(10),
        CONSTRAINT PK_MOVIMIENTOS PRIMARY KEY (ID_Movimiento),
        CONSTRAINT FK_MOV_MED FOREIGN KEY (Codigo_Med) 
            REFERENCES MEDICAMENTOS(Codigo_Med) ON DELETE CASCADE,
        CONSTRAINT CK_TIPO_MOV CHECK (Tipo IN ('Compra', 'Consumo', 'Baja'))
    )""")
    

    ##FACTURAS 

def borrartodastablas(cursor):
    cursor.execute("DROP TABLE INGRESO")
    cursor.execute("DROP TABLE PACIENTE")
    cursor.execute("DROP TABLE MOVIMIENTOS")
    cursor.execute("DROP TABLE MEDICAMENTOS")
    cursor.execute("DROP TABLE STOCK")
    cursor.execute("DROP TABLE FACTURA")
    cursor.execute("DROP TABLE SEGURO")
    cursor.execute("DROP TABLE PAGADOR")
    cursor.execute("DROP TABLE PAGAR")
    
def rellenartablas(cursor):
    cursor.execute("""INSERT INTO PACIENTE (NSS, DNI, Nombre, Apellidos, Telefono, Direccion, Fnac) VALUES
('012345678901', '12345678A', 'Juan', 'García López', '600111222', 'Calle Mayor 1, Madrid', '1985-05-15'),
('023456789012', '23456789B', 'María', 'Sánchez Pérez', '611222333', 'Av. Constitución 45, Valencia', '1990-11-20'),
('034567890123', '34567890C', 'Carlos', 'Rodríguez Ruíz', '622333444', 'Plaza España 10, Sevilla', '1978-02-28'),
('045678901234', '45678901D', 'Laura', 'Martínez Gómez', '633444555', 'Calle Real 5, Barcelona', '1995-07-12'),
('056789012345', '56789012E', 'Javier', 'Hernández Sanz', '644555666', 'Calle Nueva 22, Bilbao', '1982-09-30'),
('067890123456', '67890123F', 'Elena', 'Díaz Morales', '655666777', 'Av. del Mar 3, Málaga', '2000-01-05'),
('078901234567', '78901234G', 'Diego', 'Moreno Cano', '666777888', 'Calle Larga 14, Zaragoza', '1975-12-18'),
('089012345678', '89012345H', 'Sofía', 'Torres Vega', '677888999', 'Calle Ancha 8, Murcia', '1992-03-25'),
('090123456789', '90123456J', 'Pablo', 'Navarro Soler', '688999000', 'Paseo del Prado 12, Valladolid', '1988-06-14'),
('101234567890', '01234567K', 'Lucía', 'Castillo Rivas', '699000111', 'Calle Pino 7, Granada', '1998-10-02');""")
# --- DDL: CREAR Y BORRAR TABLAS (SOLO SUBSISTEMA PACIENTES) ---

def borrartablas(cursor):
    try:
        cursor.execute("DROP TABLE INGRESO")
    except:
        pass 
    try:
        cursor.execute("DROP TABLE PACIENTE")
    except:
        pass

def creartablas(cursor):
    create_paciente = """
    CREATE TABLE PACIENTE (
        NSS VARCHAR(12) PRIMARY KEY,
        DNI VARCHAR(9) UNIQUE,
        Nombre VARCHAR(20),
        Apellidos VARCHAR(40),
        Telefono VARCHAR(20),
        Direccion VARCHAR(100),
        Fnac DATE
    )"""

    create_ingreso = """
    CREATE TABLE INGRESO (
        Id_Ingreso VARCHAR(20) PRIMARY KEY,
        Fecha_Ingreso DATE,
        Motivo VARCHAR(250),
        Sala VARCHAR(20),
        Estado VARCHAR(20),
        NSS VARCHAR(12),
        FOREIGN KEY (NSS) REFERENCES PACIENTE(NSS)
    )"""
    

    cursor.execute(create_paciente)
    cursor.execute(create_ingreso)

# --- DML: REQUISITOS FUNCIONALES ---

def registrar_paciente(cursor, nss, dni, nombre, apellidos, tlf, direccion, fnac):
    # 1. COMPROBAR SI EXISTE EL NSS
    cursor.execute("SELECT NSS FROM PACIENTE WHERE NSS = ?", (nss,))
    if cursor.fetchone():
        return False, f"⚠️ Error: Ya existe un paciente con el Nº Seguridad Social {nss}."

    # 2. COMPROBAR SI EXISTE EL DNI
    cursor.execute("SELECT DNI FROM PACIENTE WHERE DNI = ?", (dni,))
    if cursor.fetchone():
        return False, f"⚠️ Error: Ya existe un paciente con el DNI {dni}."

    # 3. SI NO EXISTEN, INSERTAMOS
    try:
        cursor.execute(
            """INSERT INTO PACIENTE (NSS, DNI, Nombre, Apellidos, Telefono, Direccion, Fnac) 
               VALUES (?, ?, ?, ?, ?, ?, ?)""",
            (nss, dni, nombre, apellidos, tlf, direccion, fnac)
        )
        cursor.connection.commit()
        return True, f"✅ Paciente {nombre} {apellidos} registrado correctamente."
    except Exception as e:
        return False, f"❌ Error desconocido en la base de datos: {e}"

# RF 1.2: Consultar Ficha Médica (Datos + Historial)
def obtener_ficha_medica(cursor, nss):
    # 1. Obtener datos personales
    cursor.execute("SELECT * FROM PACIENTE WHERE NSS = ?", (nss,))
    paciente = cursor.fetchone()

    if not paciente:
        return None, None # Si no existe, devolvemos vacío

    # 2. Obtener historial de ingresos (Ordenado por fecha más reciente)
    cursor.execute("""
        SELECT Id_Ingreso, Fecha_Ingreso, Sala, Motivo, Estado
        FROM INGRESO
        WHERE NSS = ?
        ORDER BY Fecha_Ingreso DESC
    """, (nss,))
    historial = cursor.fetchall()

    return paciente, historial


def modificar_paciente(cursor, nss, telefono, direccion):
    cursor.execute(
        "UPDATE PACIENTE SET Telefono = ?, Direccion = ? WHERE NSS = ?",
        (telefono, direccion, nss)
    )
    
# --- RF 1.4: GESTIÓN DE INGRESOS Y ALTAS ---

# OPCIÓN A: NUEVO INGRESO (INSERT)
def registrar_nuevo_ingreso(cursor, id_ingreso, nss, fecha, motivo, sala):
    # 1. Comprobar que el paciente existe
    cursor.execute("SELECT NSS FROM PACIENTE WHERE TRIM(NSS) = ?", (nss.strip(),))
    if not cursor.fetchone():
        return False, "⚠️ Error: El paciente no existe. Regístralo primero."

    # 2. Comprobar que NO esté ya ingresado (No puedes ingresar a quien ya está dentro)
    cursor.execute("""
        SELECT Id_Ingreso FROM INGRESO 
        WHERE NSS = ? AND Estado = 'Ingresado'
    """, (nss.strip(),))
    
    if cursor.fetchone():
        return False, "⚠️ Error: Este paciente YA está ingresado actualmente. Debes darle el alta primero."

    # 3. Insertar el nuevo ingreso
    try:
        cursor.execute(
            """INSERT INTO INGRESO (Id_Ingreso, NSS, Fecha_Ingreso, Motivo, Sala, Estado) 
               VALUES (?, ?, ?, ?, ?, 'Ingresado')""",  # <--- Forzamos estado 'Ingresado' al entrar
            (id_ingreso, nss, fecha, motivo, sala)
        )
        cursor.connection.commit()
        return True, "✅ Paciente ingresado correctamente."
    except Exception as e:
        return False, f"❌ Error BD: {e}"


# OPCIÓN B: DAR DE ALTA (UPDATE)
def registrar_alta_medica(cursor, nss):
    # 1. Buscar si el paciente tiene un ingreso ACTIVO
    cursor.execute("""
        SELECT Id_Ingreso FROM INGRESO 
        WHERE NSS = ? AND Estado = 'Ingresado'
    """, (nss.strip(),))
    
    resultado = cursor.fetchone()
    
    if not resultado:
        return False, "⚠️ Error: Este paciente NO está ingresado actualmente. No se puede dar de alta."
    
    id_ingreso_activo = resultado[0]

    # 2. Actualizar esa fila: Cambiamos 'Ingresado' por 'Alta'
    try:
        cursor.execute("""
            UPDATE INGRESO 
            SET Estado = 'Alta' 
            WHERE Id_Ingreso = ?
        """, (id_ingreso_activo,))
        
        cursor.connection.commit()
        return True, f"✅ Alta registrada. El episodio {id_ingreso_activo} ha sido cerrado."
    except Exception as e:
        return False, f"❌ Error al tramitar alta: {e}"

# RF 1.5: Listar por Estado (FILTRADO POR EL ÚLTIMO EPISODIO)
def obtener_listado_estado(cursor, estado):
    # Esta consulta es un poco más avanzada ("Correlada"):
    # Selecciona el ingreso SOLO SI su fecha es la máxima (la última) de ese paciente.
    cursor.execute("""
        SELECT P.Nombre, P.Apellidos, I.Fecha_Ingreso, I.Sala, I.Motivo
        FROM INGRESO I
        JOIN PACIENTE P ON I.NSS = P.NSS
        WHERE I.Estado = ? 
        AND I.Fecha_Ingreso = (
            SELECT MAX(I2.Fecha_Ingreso)
            FROM INGRESO I2
            WHERE I2.NSS = I.NSS
        )
    """, (estado,))
    return cursor.fetchall()

def mostrar_tablas(cursor):
    col1, col2 = st.columns(2)
    with col1:
        st.write("### Tabla PACIENTE")
        try:
            cursor.execute("SELECT * FROM PACIENTE")
            rows = cursor.fetchall()
            if rows:
                rows = [tuple(x) for x in rows] 
                columnas = [column[0] for column in cursor.description]
                data = pd.DataFrame(rows, columns=columnas)
                st.dataframe(data)
            else:
                st.info("Tabla vacía")
        except Exception as e:
            st.error(f"Error: {e}")

    with col2:
        st.write("### Tabla INGRESO")
        try:
            cursor.execute("SELECT * FROM INGRESO")
            rows = cursor.fetchall()
            if rows:
                rows = [tuple(x) for x in rows]
                columnas = [column[0] for column in cursor.description]
                data = pd.DataFrame(rows, columns=columnas)
                st.dataframe(data)
            else:
                st.info("Tabla vacía")
        except Exception as e:
            st.error(f"Error: {e}")

## FUNCIONES PABLO LINARI PEREZ
def creartablasfacturas(cursor):
    cursor.execute("""
    CREATE TABLE factura (
        idfactura NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        nss VARCHAR2(12),
        dni VARCHAR2(9) NOT NULL,
        dnipagador VARCHAR2(9) DEFAULT NULL,
        nombre VARCHAR2(50),
        apellido VARCHAR2(50),
        telefono VARCHAR2(15),
        precio NUMBER(10,5),
        porcentaje NUMBER(5,5),
        recursos VARCHAR2(300)
    )""")
    cursor.execute("""
    CREATE TABLE pagador (
        dni VARCHAR2(15) PRIMARY KEY,
        nombre VARCHAR2(50),
        apellido VARCHAR2(50),
        tarjeta VARCHAR2(15)
    )""")

    cursor.execute("""
    CREATE TABLE seguro (
        idseguro NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        nss VARCHAR2(20),
        nombre VARCHAR2(50),
        correo VARCHAR2(50),
        telefono VARCHAR2(15),
        descripción VARCHAR2(250)
    )""")
def borrartablasfactura(cursor):
    cursor.execute("DROP TABLE SEGURO")
    cursor.execute("DROP TABLE FACTURA")
    cursor.execute("DROP TABLE PAGADOR")
def crearfactura(cursor, nss, precio, porcentaje, recursos):
    getsql = "SELECT DNI, Nombre, Apellidos, Telefono FROM paciente WHERE nss = ?"
    cursor.execute(getsql, (nss,))
    fila = cursor.fetchone()
    
    if fila:
        dni, nombre, apellidos, telefono = fila
        
        updatesql = """
            INSERT INTO factura (NSS, DNI, nombre, apellido, telefono, precio, porcentaje, recursos) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        datos_insert = (nss, dni, nombre, apellidos, telefono, precio, porcentaje, recursos)
        cursor.execute(updatesql, datos_insert)
        cursor.connection.commit()
        return True
    else:
        print(f"Error: No se encontró ningún paciente con NSS {nss}")
        return False
def modificarfactura(cursor,datos,idfac):
    getsql = "SELECT idfactura FROM factura WHERE idfactura = ?"
    cursor.execute(getsql, (idfac,))
    fila = cursor.fetchone()
    
    if not fila:
        return False

    partes_sql = [f"{columna} = ?" for columna in datos.keys()]
    
    cadenadatos = ", ".join(partes_sql)

    updatesql = f"UPDATE factura SET {cadenadatos} WHERE idfactura = ?"
    
    valores = list(datos.values())
    valores.append(idfac)

    cursor.execute(updatesql, valores)
    cursor.connection.commit()    
    return True


def registrarpagador(cursor,dni,npagador,apagador,ntarjeta,idfac):
    
    updatepagador="""INSERT INTO pagador (dni,nombre,apellido,tarjeta) VALUES (?, ?, ?, ?)"""
    cursor.execute(updatepagador,(dni,npagador,apagador,ntarjeta))
    cursor.connection.commit()

    updatepago="""UPDATE factura SET dnipagador=? WHERE idfactura=?"""
    cursor.execute(updatepago,(dni,idfac))
    cursor.connection.commit()

def registrapago(cursor,dni,idfactura):

    updatepago="""UPDATE factura SET dnipagador=? WHERE idfactura=?"""
    cursor.execute(updatepago,(dni,idfactura))
    cursor.connection.commit()

# ========================================================================
# SUBSISTEMA DE MEDICAMENTOS - PRÁCTICA 3
# ========================================================================

# --- DDL: CREAR Y BORRAR TABLAS MEDICAMENTOS ---

def borrar_tablas_medicamentos(cursor):
    """Elimina las tablas del subsistema de medicamentos en orden correcto."""
    errores = []
    
    try:
        cursor.execute("DROP TABLE MOVIMIENTOS CASCADE CONSTRAINTS")
        cursor.connection.commit()
    except Exception as e:
        if "ORA-00942" not in str(e):  # Ignorar si no existe
            errores.append(f"MOVIMIENTOS: {str(e)[:100]}")
    
    try:
        cursor.execute("DROP TABLE STOCK CASCADE CONSTRAINTS")
        cursor.connection.commit()
    except Exception as e:
        if "ORA-00942" not in str(e):  # Ignorar si no existe
            errores.append(f"STOCK: {str(e)[:100]}")
    
    try:
        cursor.execute("DROP TABLE MEDICAMENTOS CASCADE CONSTRAINTS")
        cursor.connection.commit()
    except Exception as e:
        if "ORA-00942" not in str(e):  # Ignorar si no existe
            errores.append(f"MEDICAMENTOS: {str(e)[:100]}")
    
    if errores:
        return False, "Errores al borrar: " + "; ".join(errores)
    return True, "Tablas eliminadas correctamente"

def crear_tablas_medicamentos(cursor):
    """Crea las tablas del subsistema de medicamentos con sus restricciones."""
    
    # Tabla principal de medicamentos
    create_medicamentos = """
    CREATE TABLE MEDICAMENTOS (
        Codigo_Med VARCHAR2(10) NOT NULL,
        Nombre VARCHAR2(50) NOT NULL,
        Proveedor VARCHAR2(50),
        Coste NUMBER(10, 2),
        Precio NUMBER(10, 2),
        F_Registro DATE DEFAULT SYSDATE,
        CONSTRAINT PK_MEDICAMENTOS PRIMARY KEY (Codigo_Med)
    )"""
    
    # Tabla de control de stock por lotes
    create_stock = """
    CREATE TABLE STOCK (
        Codigo_Med VARCHAR2(10) NOT NULL,
        Lote VARCHAR2(20) NOT NULL,
        Cantidad NUMBER(10) DEFAULT 0 NOT NULL,
        F_Caducidad DATE NOT NULL,
        CONSTRAINT PK_STOCK PRIMARY KEY (Codigo_Med, Lote),
        CONSTRAINT FK_STOCK_MED FOREIGN KEY (Codigo_Med) 
            REFERENCES MEDICAMENTOS(Codigo_Med) ON DELETE CASCADE,
        CONSTRAINT CK_STOCK_POSITIVO CHECK (Cantidad >= 0)
    )"""
    
    # Tabla de historial de movimientos
    create_movimientos = """
    CREATE TABLE MOVIMIENTOS (
        ID_Movimiento NUMBER GENERATED BY DEFAULT AS IDENTITY,
        Codigo_Med VARCHAR2(10) NOT NULL,
        Fecha DATE DEFAULT SYSDATE NOT NULL,
        Tipo VARCHAR2(20) NOT NULL,
        Cantidad NUMBER(10) NOT NULL,
        ID_Admin VARCHAR2(10),
        CONSTRAINT PK_MOVIMIENTOS PRIMARY KEY (ID_Movimiento),
        CONSTRAINT FK_MOV_MED FOREIGN KEY (Codigo_Med) 
            REFERENCES MEDICAMENTOS(Codigo_Med) ON DELETE CASCADE,
        CONSTRAINT CK_TIPO_MOV CHECK (Tipo IN ('Compra', 'Consumo', 'Baja'))
    )"""
    
    cursor.execute(create_medicamentos)
    cursor.execute(create_stock)
    cursor.execute(create_movimientos)

def crear_triggers_medicamentos(cursor):
    """
    Crea triggers para validar restricciones semánticas:
    - RS4.3: Stock no puede ser negativo
    - RS4.4: Fecha de caducidad debe ser futura para nuevo stock
    """
    
    trigger_validar_stock = """
    CREATE OR REPLACE TRIGGER TRG_VALIDAR_STOCK
    BEFORE INSERT OR UPDATE ON STOCK
    FOR EACH ROW
    BEGIN
        -- RS4.3: El stock total no puede ser negativo
        IF :NEW.Cantidad < 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 
                'Error RS4.3: Stock Insuficiente. La cantidad no puede ser negativa.');
        END IF;

        -- RS4.4: Validez de la Fecha de Caducidad al añadir stock
        -- Si estamos insertando o aumentando la cantidad (compra)
        IF :NEW.Cantidad > NVL(:OLD.Cantidad, 0) THEN
            IF :NEW.F_Caducidad < SYSDATE THEN
                RAISE_APPLICATION_ERROR(-20002, 
                    'Error RS4.4: La fecha de caducidad debe ser futura para nuevo stock.');
            END IF;
        END IF;
    END;
    """
    
    cursor.execute(trigger_validar_stock)


# --- DML: REQUISITOS FUNCIONALES ---

def registrar_medicamento(cursor, codigo, nombre, proveedor, coste, precio, 
                         lote_inicial=None, cantidad_inicial=None, f_caducidad=None):
    """
    RF4.1: Registrar nuevo medicamento con stock inicial opcional.
    Transacción que inserta en MEDICAMENTOS y opcionalmente en STOCK.
    """
    
    # 1. Verificar que el código no exista
    cursor.execute("SELECT Codigo_Med FROM MEDICAMENTOS WHERE Codigo_Med = ?", (codigo,))
    if cursor.fetchone():
        return False, f"Error: Ya existe un medicamento con el código {codigo}."
    
    try:
        # 2. Insertar medicamento
        cursor.execute("""
            INSERT INTO MEDICAMENTOS (Codigo_Med, Nombre, Proveedor, Coste, Precio, F_Registro)
            VALUES (?, ?, ?, ?, ?, SYSDATE)
        """, (codigo, nombre, proveedor, coste, precio))
        
        # 3. Si hay lote inicial, crear stock
        if lote_inicial and cantidad_inicial and f_caducidad:
            cursor.execute("""
                INSERT INTO STOCK (Codigo_Med, Lote, Cantidad, F_Caducidad)
                VALUES (?, ?, ?, ?)
            """, (codigo, lote_inicial, cantidad_inicial, f_caducidad))
            
            # 4. Registrar movimiento de compra inicial
            cursor.execute("""
                INSERT INTO MOVIMIENTOS (Codigo_Med, Fecha, Tipo, Cantidad, ID_Admin)
                VALUES (?, SYSDATE, 'Compra', ?, 'SISTEMA')
            """, (codigo, cantidad_inicial))
        
        cursor.connection.commit()
        return True, f"Medicamento {nombre} registrado correctamente."
    
    except Exception as e:
        cursor.connection.rollback()
        return False, f"Error al registrar medicamento: {e}"


def actualizar_stock(cursor, codigo, lote, cantidad, tipo_movimiento, id_admin='ADMIN'):
    """
    RF4.3: Actualizar stock (entrada/salida).
    RF4.5: Registra el movimiento en el historial.
    
    Tipos de movimiento:
    - 'Compra': Añade stock (+)
    - 'Consumo': Reduce stock (-)
    - 'Baja': Reduce stock por caducidad/daño (-)
    - 'Ajuste': Puede ser + o -
    """
    
    # 1. Verificar que el medicamento existe
    cursor.execute("SELECT Codigo_Med FROM MEDICAMENTOS WHERE Codigo_Med = ?", (codigo,))
    if not cursor.fetchone():
        return False, f"Error: No existe un medicamento con código {codigo}."
    
    try:
        # 2. Verificar si existe el lote
        cursor.execute("""
            SELECT Cantidad FROM STOCK 
            WHERE Codigo_Med = ? AND Lote = ?
        """, (codigo, lote))
        
        resultado = cursor.fetchone()
        
        # Determinar la cantidad real según el tipo de movimiento
        if tipo_movimiento in ['Consumo', 'Baja']:
            cantidad_cambio = -abs(cantidad)  # Siempre negativo
        else:  # Compra o Ajuste
            cantidad_cambio = cantidad  # Usar el signo que venga
        
        if resultado:
            # 3a. Actualizar stock existente
            cantidad_actual = resultado[0]
            nueva_cantidad = cantidad_actual + cantidad_cambio
            
            if nueva_cantidad < 0:
                return False, f"Error: Stock insuficiente. Actual: {cantidad_actual}, Solicitado: {abs(cantidad_cambio)}"
            
            cursor.execute("""
                UPDATE STOCK 
                SET Cantidad = ?
                WHERE Codigo_Med = ? AND Lote = ?
            """, (nueva_cantidad, codigo, lote))
        else:
            # 3b. Solo permitir crear nuevo lote si es compra/entrada (cantidad positiva)
            if cantidad_cambio <= 0:
                return False, f"Error: El lote {lote} no existe. Solo se pueden crear lotes con compras (cantidad positiva)."
            
            # Necesitamos fecha de caducidad para nuevo lote - esto se debe manejar en la UI
            return False, f"Error: El lote {lote} no existe. Usa 'Registrar Medicamento' para crear el primer lote."
        
        # 4. Registrar el movimiento en el historial
        cursor.execute("""
            INSERT INTO MOVIMIENTOS (Codigo_Med, Fecha, Tipo, Cantidad, ID_Admin)
            VALUES (?, SYSDATE, ?, ?, ?)
        """, (codigo, tipo_movimiento, abs(cantidad), id_admin))
        
        cursor.connection.commit()
        return True, f"Stock actualizado. Operación: {tipo_movimiento}, Cantidad: {cantidad_cambio}"
    
    except Exception as e:
        cursor.connection.rollback()
        return False, f"Error al actualizar stock: {e}"


def añadir_lote_nuevo(cursor, codigo, lote, cantidad, f_caducidad, id_admin='ADMIN'):
    """
    Añade un nuevo lote de un medicamento existente.
    Se usa cuando se recibe una nueva compra con lote diferente.
    """
    
    # 1. Verificar que el medicamento existe
    cursor.execute("SELECT Codigo_Med FROM MEDICAMENTOS WHERE Codigo_Med = ?", (codigo,))
    if not cursor.fetchone():
        return False, f"Error: No existe un medicamento con código {codigo}."
    
    # 2. Verificar que el lote no exista ya
    cursor.execute("""
        SELECT Lote FROM STOCK 
        WHERE Codigo_Med = ? AND Lote = ?
    """, (codigo, lote))
    
    if cursor.fetchone():
        return False, f"Error: Ya existe el lote {lote} para este medicamento. Usa 'Actualizar Stock'."
    
    try:
        # 3. Insertar nuevo lote (el trigger validará la fecha de caducidad)
        cursor.execute("""
            INSERT INTO STOCK (Codigo_Med, Lote, Cantidad, F_Caducidad)
            VALUES (?, ?, ?, ?)
        """, (codigo, lote, cantidad, f_caducidad))
        
        # 4. Registrar movimiento
        cursor.execute("""
            INSERT INTO MOVIMIENTOS (Codigo_Med, Fecha, Tipo, Cantidad, ID_Admin)
            VALUES (?, SYSDATE, 'Compra', ?, ?)
        """, (codigo, cantidad, id_admin))
        
        cursor.connection.commit()
        return True, f"Nuevo lote {lote} añadido con {cantidad} unidades."
    
    except Exception as e:
        cursor.connection.rollback()
        return False, f"Error al añadir lote: {e}"


def consultar_medicamento(cursor, codigo):
    """Obtiene información completa de un medicamento."""
    cursor.execute("SELECT * FROM MEDICAMENTOS WHERE Codigo_Med = ?", (codigo,))
    return cursor.fetchone()


def consultar_stock_total(cursor, codigo):
    """Calcula el stock total de un medicamento (suma de todos los lotes)."""
    cursor.execute("""
        SELECT COALESCE(SUM(Cantidad), 0) 
        FROM STOCK 
        WHERE Codigo_Med = ?
    """, (codigo,))
    resultado = cursor.fetchone()
    return resultado[0] if resultado else 0


def listar_medicamentos(cursor):
    """Lista todos los medicamentos con su stock total."""
    cursor.execute("""
        SELECT 
            M.Codigo_Med,
            M.Nombre,
            M.Proveedor,
            M.Coste,
            M.Precio,
            COALESCE(SUM(S.Cantidad), 0) as Stock_Total,
            M.F_Registro
        FROM MEDICAMENTOS M
        LEFT JOIN STOCK S ON M.Codigo_Med = S.Codigo_Med
        GROUP BY M.Codigo_Med, M.Nombre, M.Proveedor, M.Coste, M.Precio, M.F_Registro
        ORDER BY M.Nombre
    """)
    return cursor.fetchall()


def listar_stock_por_medicamento(cursor, codigo):
    """Lista todos los lotes de un medicamento específico."""
    cursor.execute("""
        SELECT Lote, Cantidad, F_Caducidad
        FROM STOCK
        WHERE Codigo_Med = ?
        ORDER BY F_Caducidad
    """, (codigo,))
    return cursor.fetchall()


def listar_movimientos(cursor, codigo=None, limit=50):
    """
    Lista el historial de movimientos.
    Si se especifica código, filtra por ese medicamento.
    """
    if codigo:
        cursor.execute("""
            SELECT 
                M.ID_Movimiento,
                M.Codigo_Med,
                MED.Nombre,
                M.Fecha,
                M.Tipo,
                M.Cantidad,
                M.ID_Admin
            FROM MOVIMIENTOS M
            JOIN MEDICAMENTOS MED ON M.Codigo_Med = MED.Codigo_Med
            WHERE M.Codigo_Med = ?
            ORDER BY M.Fecha DESC
            FETCH FIRST ? ROWS ONLY
        """, (codigo, limit))
    else:
        cursor.execute("""
            SELECT 
                M.ID_Movimiento,
                M.Codigo_Med,
                MED.Nombre,
                M.Fecha,
                M.Tipo,
                M.Cantidad,
                M.ID_Admin
            FROM MOVIMIENTOS M
            JOIN MEDICAMENTOS MED ON M.Codigo_Med = MED.Codigo_Med
            ORDER BY M.Fecha DESC
            FETCH FIRST ? ROWS ONLY
        """, (limit,))
    
    return cursor.fetchall()


def listar_medicamentos_por_caducar(cursor, dias=30):
    """Lista medicamentos con lotes próximos a caducar."""
    cursor.execute("""
        SELECT 
            M.Codigo_Med,
            M.Nombre,
            S.Lote,
            S.Cantidad,
            S.F_Caducidad,
            (S.F_Caducidad - SYSDATE) as Dias_Restantes
        FROM STOCK S
        JOIN MEDICAMENTOS M ON S.Codigo_Med = M.Codigo_Med
        WHERE S.F_Caducidad <= SYSDATE + ?
        AND S.Cantidad > 0
        ORDER BY S.F_Caducidad
    """, (dias,))
    return cursor.fetchall()


def mostrar_tablas_medicamentos(cursor):
    """Muestra las tres tablas del subsistema en Streamlit."""
    
    st.write("### Tabla MEDICAMENTOS")
    try:
        cursor.execute("SELECT * FROM MEDICAMENTOS")
        rows = cursor.fetchall()
        if rows:
            rows = [tuple(x) for x in rows]
            columnas = [column[0] for column in cursor.description]
            data = pd.DataFrame(rows, columns=columnas)
            st.dataframe(data, use_container_width=True)
        else:
            st.info("Tabla vacía")
    except Exception as e:
        st.error(f"Error: {e}")
    
    st.write("### Tabla STOCK")
    try:
        cursor.execute("""
            SELECT S.*, M.Nombre as Nombre_Medicamento
            FROM STOCK S
            JOIN MEDICAMENTOS M ON S.Codigo_Med = M.Codigo_Med
            ORDER BY S.Codigo_Med, S.F_Caducidad
        """)
        rows = cursor.fetchall()
        if rows:
            rows = [tuple(x) for x in rows]
            columnas = [column[0] for column in cursor.description]
            data = pd.DataFrame(rows, columns=columnas)
            st.dataframe(data, use_container_width=True)
        else:
            st.info("Tabla vacía")
    except Exception as e:
        st.error(f"Error: {e}")
    
    st.write("### Tabla MOVIMIENTOS")
    try:
        cursor.execute("""
            SELECT M.*, MED.Nombre as Nombre_Medicamento
            FROM MOVIMIENTOS M
            JOIN MEDICAMENTOS MED ON M.Codigo_Med = MED.Codigo_Med
            ORDER BY M.Fecha DESC
            FETCH FIRST 50 ROWS ONLY
        """)
        rows = cursor.fetchall()
        if rows:
            rows = [tuple(x) for x in rows]
            columnas = [column[0] for column in cursor.description]
            data = pd.DataFrame(rows, columns=columnas)
            st.dataframe(data, use_container_width=True)
        else:
            st.info("Tabla vacía")
    except Exception as e:
        st.error(f"Error: {e}")




